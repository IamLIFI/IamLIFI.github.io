---
layout:     post                    # 使用的布局（不需要改）
title:      java 垃圾回收机制     # 标题
subtitle:    #副标题
date:       2019-5-19           # 时间
author:     IamLIFI                     # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Java基础

---

## Java垃圾回收机制

*Java*有垃圾回收器负责回收无用对象占据的内存资源。而且垃圾回收器只知道释放那些经*new*分配的内存，但是如果一个对象不是经过new分配的那么，他就不知道怎么释放这块特殊的内存。

为了应对这个情况，，Java允许再类中定义一个finalize()方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的内存空间，首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

> finalize()和C++中的析构函数不同。在C++中对象一定会被销毁并且调用析构函数，但是在Java中对象却并非总是被垃圾回收。这就是说，在你不需要某个对象之前，如果必须执行某些动作，那么得自己去做。Java并没有“析构函数”或者相似的概念，要做类似的清理工作，就必须自己动手创建一个执行清理工作的普通方法。

1. **对象可能不被垃圾回收。**
2. **垃圾回收并不等于析构。**
3. **垃圾回收只与内存有关。**



## finalize()的用途

垃圾回收只与内存有关。使用垃圾回收器的唯一原因就是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），他们必须与内存及其回收有关。

在Java中一切皆为对象，但是Java可以调用非Java代码，而C/C++中的malloc()函数会分配新的内存，但是如果不调用free()方法那内存就永远得不到释放，从而造成内存泄漏，当然， free()是C/C++中的函数，所以需要在finalize()中用本地方法调用它。



## 用户必须实施清理

用户必须在需要清理的时刻调用执行清理动作的方法。

Java虚拟机不会在并未面临内存耗尽的情形下，浪费时间去执行垃圾回收以恢复内存。



## 垃圾回收器的工作原理

> 1. C++中，对象既可以建在堆上，也可以建在堆栈中，但是在堆上的对象如果不用了，程序员需要自己回收空间；C++中堆(heap)是动态的，堆栈(stack)是静态和全局的。
> 2. java中，对象都建在堆上，系统会自动回收不再使用的空间，Java在堆上分配空间的速度和C++在堆栈上分分配空间的速度差不多；
> 3. java中的堆对应的也是C++中的堆，只不过C++多一种在堆栈中放对象的方式；
> 4. java中也有堆栈，但一般只存储一些引用和基本变量，不放对象，程序员通常也不需要去管。

C++中堆的管理方式是一个院子，里面每一个对象都负责管理自己的地盘，对象可能被销毁，但是地盘必须可以被重用。

但是在Java中堆的管理像是一个传送带，每分配一个新对象，他就往前移动，移动至尚未分配到区域，当内存快满的时候，垃圾回收器就开始工作，一边回收空间，一边使堆中的对象紧凑排列。

#### 实现方法

1. **引用计数**

   这个算法的实现是，给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数器值+1；当引用失效时，计数器值-1。任何时刻计数值为0的对象就是不可能再被使用的。这种算法使用场景很多，但是，Java中却没有使用这种算法，因为这种算法很难解决对象之间相互引用的情况。

2. **可达性分析法**

   这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。

   那么问题又来了，如何选取GCRoots对象呢？在Java语言中，可以作为GCRoots的对象包括下面几种：

   (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

   (2). 方法区中的类静态属性引用的对象。

   (3). 方法区中常量引用的对象。

   (4). 本地方法栈中JNI(Native方法)引用的对象。

   > (1)首先第一种是虚拟机栈中的引用的对象，我们在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。
   >
   > (2)第二种是我们在类中定义了全局的静态的对象，也就是使用了static关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为GC Roots是必须的。
   >
   > (3)第三种便是常量引用，就是使用了static final关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为GC Roots。最后一种是在使用JNI技术时，有时候单纯的Java代码并不能满足我们的需求，我们可能需要在Java中调用C或C++的代码，因此会使用native方法，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots。

3. 在可达性分析法下的实现方法。

   上面已经知道，所有 GC Roots 不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。

   ![1](https://raw.githubusercontent.com/IamLIFI/IamLIFI.github.io/master/img/190519/1.png)

   (1) 标记－清理 (容易产生 内存碎片)

   第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；
   第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接 清空 即可。

   结果如下:

   ![1](https://raw.githubusercontent.com/IamLIFI/IamLIFI.github.io/master/img/190519/2.png)



   (2) 标记－整理

   既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有 存活 对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。

   结果如下：

   ![1](https://raw.githubusercontent.com/IamLIFI/IamLIFI.github.io/master/img/190519/3.png)

   (3) 复制

   这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有 存活 对象全部复制到另一块内存上，当前内存则直接全部清空。

   起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。

   这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的 复制清空。

   这种方案适合 存活对象少，垃圾多 的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。

   参考下图:

   ![1](https://raw.githubusercontent.com/IamLIFI/IamLIFI.github.io/master/img/190519/4.png)

#### 参考博客：

<http://www.importnew.com/26821.html>

<https://blog.csdn.net/luzhensmart/article/details/81431212>